#include "lcd_lib.h"

//-------------variables-----------------------------------------------------
LCD_STRUCT lcdStruct = { 0x00, 0, 0, LCD_WriteSymbolToBuffer, LCD_WriteStringToBuffer, 
                         LCD_DisplayFullUpdate, 0, LCD_ClearOrFillDisplay};
const uint8_t LIBRARY_SYMBOL[] = 	           // Согласно таблице ASCII
{
  // 0x00 - пустое знакоместо.
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  // 0x01 - лицо с улыбкой.
  0x00, 0x3e, 0x45, 0x51, 0x45, 0x3e,

  // 0x02 - лицо с улыбкой закрашенное.
  0x00, 0x3e, 0x6b, 0x6f, 0x6b, 0x3e,

  // 0x03 - червы (сердце).
  0x00, 0x1c, 0x3e, 0x7c, 0x3e, 0x1c,

  // 0x04 - бубны.
  0x00, 0x18, 0x3c, 0x7e, 0x3c, 0x18,

  // 0x05 - крести.
  0x00, 0x30, 0x36, 0x7f, 0x36, 0x30,

  // 0x06 - вини.
  0x00, 0x18, 0x5c, 0x7e, 0x5c, 0x18,

  // 0x07 - закрашенный круг по центру.
  0x00, 0x00, 0x18, 0x18, 0x00, 0x00,

  // 0x08 - закрашенный круг по центру в инверсии.
  0xff, 0xff, 0xe7, 0xe7, 0xff, 0xff,

  // 0x09 - незакрашенный круг по центру.
  0x00, 0x3c, 0x24, 0x24, 0x3c, 0x00,

  // 0x0a - незакрашенный круг по центру в инверсии (кольцо).
  0xff, 0xc3, 0xdb, 0xdb, 0xc3, 0xff,

  // 0x0b - мужской символ (круг со стрелкой вверх).
  0x00, 0x30, 0x48, 0x4a, 0x36, 0x0e,

  // 0x0c - женский символ (круг с крестом внизу).
  0x00, 0x06, 0x29, 0x79, 0x29, 0x06,

  // 0x0d - нота I.
  0x00, 0x60, 0x70, 0x3f, 0x02, 0x04,

  // 0x0e - нота II.
  0x00, 0x60, 0x7e, 0x0a, 0x35, 0x3f,

  // 0x0f - солнце (круг с расходящимися лучами).
  0x00, 0x2a, 0x1c, 0x36, 0x1c, 0x2a,

  // 0x10 - толстая стрелка вправо.
  0x00, 0x00, 0x7f, 0x3e, 0x1c, 0x08,

  // 0x11 - толстая стрелка влево.
  0x00, 0x08, 0x1c, 0x3e, 0x7f, 0x00,

  // 0x12 - тонкая стрелка вверх-вниз.
  0x00, 0x14, 0x36, 0x7f, 0x36, 0x14,

  // 0x13 - два восклицательных знака.
  0x00, 0x00, 0x5f, 0x00, 0x5f, 0x00,

  // 0x14 - символ "Пи".
  0x00, 0x06, 0x09, 0x7f, 0x01, 0x7f,

  // 0x15 - символ параграфа.
  0x00, 0x22, 0x4d, 0x55, 0x59, 0x22,

  // 0x16 - широкое подчеркивание.
  0x00, 0x60, 0x60, 0x60, 0x60, 0x00,

  // 0x17 - тонкая стрелка вверх-вниз с подчеркиванием.
  0x00, 0x14, 0xb6, 0xff, 0xb6, 0x14,

  // 0x18 - тонкая стрелка вверх.
  0x00, 0x04, 0x06, 0x7f, 0x06, 0x04,

  // 0x19 - тонкая стрелка вниз.
  0x00, 0x10, 0x30, 0x7f, 0x30, 0x10,

  // 0x1a - тонкая стрелка вправо.
  0x00, 0x08, 0x08, 0x3e, 0x1c, 0x08,

  // 0x1b - тонкая стрелка влево.
  0x00, 0x08, 0x1c, 0x3e, 0x08, 0x08,

  // 0x1c - символ отступа.
  0x00, 0x78, 0x40, 0x40, 0x40, 0x40,

  // 0x1d - тонкая стрелка влево-вправо.
  0x00, 0x08, 0x3e, 0x08, 0x3e, 0x08,

  // 0x1e - толстая стрелка вверх.
  0x00, 0x30, 0x3c, 0x3f, 0x3c, 0x30,

  // 0x1f - толстая стрелка вниз.
  0x00, 0x03, 0x0f, 0x3f, 0x0f, 0x03,

  // 0x20 - пробел (пустое знакоместо).
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  // 0x21 - восклицательный знак.
  0x00, 0x00, 0x06, 0x5f, 0x06, 0x00,

  // 0x22 - двойная кавычка.
  0x00, 0x07, 0x03, 0x00, 0x07, 0x03,

  // 0x23 - решетка.
  0x00, 0x24, 0x7e, 0x24, 0x7e, 0x24,

  // 0x24 - доллар.
  0x00, 0x24, 0x2b, 0x6a, 0x12, 0x00,

  // 0x25 - процент.
  0x00, 0x63, 0x13, 0x08, 0x64, 0x63,

  // 0x26 - амперсанд.
  0x00, 0x36, 0x49, 0x56, 0x20, 0x50,

  // 0x27 - апостроф.
  0x00, 0x00, 0x07, 0x03, 0x00, 0x00,

  // 0x28 - открывающая скобка.
  0x00, 0x00, 0x3e, 0x41, 0x00, 0x00,

  // 0x29 - закрывающая скобка.
  0x00, 0x00, 0x41, 0x3e, 0x00, 0x00,

  // 0x2a - звездочка (умножение).
  0x00, 0x08, 0x3e, 0x1c, 0x3e, 0x08,

  // 0x2b - плюс.
  0x00, 0x08, 0x08, 0x3e, 0x08, 0x08,

  // 0x2c - запятая.
  0x00, 0x00, 0xe0, 0x60, 0x00, 0x00,

  // 0x2d - тире.
  0x00, 0x08, 0x08, 0x08, 0x08, 0x08,

  // 0x2e - точка.
  0x00, 0x00, 0x60, 0x60, 0x00, 0x00,

  // 0x2f - слеш слева-направо ('/').
  0x00, 0x20, 0x10, 0x08, 0x04, 0x02,

  // 0x30 - '0'.
  0x00, 0x3e, 0x41, 0x41, 0x41, 0x3e,

  // 0x31 - '1'.
  0x00, 0x00, 0x42, 0x7f, 0x40, 0x00,

  // 0x32 - '2'.
  0x00, 0x62, 0x51, 0x49, 0x49, 0x46,

  // 0x33 - '3'.
  0x00, 0x22, 0x49, 0x49, 0x49, 0x36,

  // 0x34 - '4'.
  0x00, 0x18, 0x14, 0x12, 0x7f, 0x10,

  // 0x35 - '5'.
  0x00, 0x2f, 0x49, 0x49, 0x49, 0x31,

  // 0x36 - '6'.
  0x00, 0x3c, 0x4a, 0x49, 0x49, 0x30,

  // 0x37 - '7'.
  0x00, 0x01, 0x71, 0x09, 0x05, 0x03,

  // 0x38 - '8'.
  0x00, 0x36, 0x49, 0x49, 0x49, 0x36,

  // 0x39 - '9'.
  0x00, 0x06, 0x49, 0x49, 0x29, 0x1e,

  // 0x3a - двоеточие.
  0x00, 0x00, 0x6c, 0x6c, 0x00, 0x00,

  // 0x3b - точка с запятой.
  0x00, 0x00, 0xec, 0x6c, 0x00, 0x00,

  // 0x3c - меньше.
  0x00, 0x08, 0x14, 0x22, 0x41, 0x00,

  // 0x3d - равно.
  0x00, 0x24, 0x24, 0x24, 0x24, 0x24,

  // 0x3e - больше.
  0x00, 0x00, 0x41, 0x22, 0x14, 0x08,

  // 0x3f - вопросительный знак.
  0x00, 0x02, 0x01, 0x59, 0x09, 0x06,

  // 0x40 - "собака" ('@').
  0x00, 0x3e, 0x41, 0x5d, 0x55, 0x1e,

  // 0x41 - 'A'.
  0x00, 0x7e, 0x11, 0x11, 0x11, 0x7e,

  // 0x42 - 'B'.
  0x00, 0x7f, 0x49, 0x49, 0x49, 0x36,

  // 0x43 - 'C'.
  0x00, 0x3e, 0x41, 0x41, 0x41, 0x22,

  // 0x44 - 'D'.
  0x00, 0x7f, 0x41, 0x41, 0x41, 0x3e,

  // 0x45 - 'E'.
  0x00, 0x7f, 0x49, 0x49, 0x49, 0x41,

  // 0x46 - 'F'.
  0x00, 0x7f, 0x09, 0x09, 0x09, 0x01,

  // 0x47 - 'G'.
  0x00, 0x3e, 0x41, 0x49, 0x49, 0x7a,

  // 0x48 - 'H'.
  0x00, 0x7f, 0x08, 0x08, 0x08, 0x7f,

  // 0x49 - 'I'.
  0x00, 0x00, 0x41, 0x7f, 0x41, 0x00,

  // 0x4a - 'J'.
  0x00, 0x30, 0x40, 0x40, 0x40, 0x3f,

  // 0x4b - 'K'.
  0x00, 0x7f, 0x08, 0x14, 0x22, 0x41,

  // 0x4c - 'L'.
  0x00, 0x7f, 0x40, 0x40, 0x40, 0x40,

  // 0x4d - 'M'.
  0x00, 0x7f, 0x02, 0x04, 0x02, 0x7f,

  // 0x4e - 'N'.
  0x00, 0x7f, 0x02, 0x04, 0x08, 0x7f,

  // 0x4f - 'O'.
  0x00, 0x3e, 0x41, 0x41, 0x41, 0x3e,

  // 0x50 - 'P'.
  0x00, 0x7f, 0x09, 0x09, 0x09, 0x06,

  // 0x51 - 'Q'.
  0x00, 0x3e, 0x41, 0x51, 0x21, 0x5e,

  // 0x52 - 'R'.
  0x00, 0x7f, 0x09, 0x09, 0x19, 0x66,

  // 0x53 - 'S'.
  0x00, 0x26, 0x49, 0x49, 0x49, 0x32,

  // 0x54 - 'T'.
  0x00, 0x01, 0x01, 0x7f, 0x01, 0x01,

  // 0x55 - 'U'.
  0x00, 0x3f, 0x40, 0x40, 0x40, 0x3f,

  // 0x56 - 'V'.
  0x00, 0x1f, 0x20, 0x40, 0x20, 0x1f,

  // 0x57 - 'W'.
  0x00, 0x3f, 0x40, 0x3c, 0x40, 0x3f,

  // 0x58 - 'X'.
  0x00, 0x63, 0x14, 0x08, 0x14, 0x63,

  // 0x59 - 'Y'.
  0x00, 0x07, 0x08, 0x70, 0x08, 0x07,

  // 0x5a - 'Z'.
  0x00, 0x71, 0x49, 0x45, 0x43, 0x00,

  // 0x5b - '['.
  0x00, 0x00, 0x7f, 0x41, 0x41, 0x00,

  // 0x5c - '\'.
  0x00, 0x02, 0x04, 0x08, 0x10, 0x20,

  // 0x5d - ']'.
  0x00, 0x00, 0x41, 0x41, 0x7f, 0x00,

  // 0x5e - '^'.
  0x00, 0x04, 0x02, 0x01, 0x02, 0x04,

  // 0x5f - '_'.
  0x80, 0x80, 0x80, 0x80, 0x80, 0x80,

  // 0x60 - обратный апостроф.
  0x00, 0x00, 0x03, 0x07, 0x00, 0x00,

  // 0x61 - 'a'.
  0x00, 0x20, 0x54, 0x54, 0x54, 0x78,

  // 0x62 - 'b'.
  0x00, 0x7f, 0x44, 0x44, 0x44, 0x38,

  // 0x63 - 'c'.
  0x00, 0x38, 0x44, 0x44, 0x44, 0x28,

  // 0x64 - 'd'.
  0x00, 0x38, 0x44, 0x44, 0x44, 0x7f,

  // 0x65 - 'e'.
  0x00, 0x38, 0x54, 0x54, 0x54, 0x08,

  // 0x66 - 'f'.
  0x00, 0x08, 0x7e, 0x09, 0x09, 0x00,

  // 0x67 - 'g'.
  0x00, 0x18, 0xa4, 0xa4, 0xa4, 0x7c,

  // 0x68 - 'h'.
  0x00, 0x7f, 0x04, 0x04, 0x78, 0x00,

  // 0x69 - 'i'.
  0x00, 0x00, 0x00, 0x7d, 0x40, 0x00,

  // 0x6a - 'j'.
  0x00, 0x40, 0x80, 0x84, 0x7d, 0x00,

  // 0x6b - 'k'.
  0x00, 0x7f, 0x10, 0x28, 0x44, 0x00,

  // 0x6c - 'l'.
  0x00, 0x00, 0x00, 0x7f, 0x40, 0x00,

  // 0x6d - 'm'.
  0x00, 0x7c, 0x04, 0x18, 0x04, 0x78,

  // 0x6e - 'n'.
  0x00, 0x7c, 0x04, 0x04, 0x78, 0x00,

  // 0x6f - 'o'.
  0x00, 0x38, 0x44, 0x44, 0x44, 0x38,

  // 0x70 - 'p'.
  0x00, 0xfc, 0x44, 0x44, 0x44, 0x38,

  // 0x71 - 'q'.
  0x00, 0x38, 0x44, 0x44, 0x44, 0xfc,

  // 0x72 - 'r'.
  0x00, 0x44, 0x78, 0x44, 0x04, 0x08,

  // 0x73 - 's'.
  0x00, 0x08, 0x54, 0x54, 0x54, 0x20,

  // 0x74 - 't'.
  0x00, 0x04, 0x3e, 0x44, 0x24, 0x00,

  // 0x75 - 'u'.
  0x00, 0x3c, 0x40, 0x20, 0x7c, 0x00,

  // 0x76 - 'v'.
  0x00, 0x1c, 0x20, 0x40, 0x20, 0x1c,

  // 0x77 - 'w'.
  0x00, 0x3c, 0x60, 0x30, 0x60, 0x3c,

  // 0x78 - 'x'.
  0x00, 0x6c, 0x10, 0x10, 0x6c, 0x00,

  // 0x79 - 'y'.
  0x00, 0x9c, 0xa0, 0x60, 0x3c, 0x00,

  // 0x7a - 'z'.
  0x00, 0x64, 0x54, 0x54, 0x4c, 0x00,

  // 0x7b - '{'.
  0x00, 0x08, 0x3e, 0x41, 0x41, 0x00,

  // 0x7c - '|'.
  0x00, 0x00, 0x00, 0x77, 0x00, 0x00,

  // 0x7d - '}'.
  0x00, 0x00, 0x41, 0x41, 0x3e, 0x08,

  // 0x7e - '~'.
  0x00, 0x02, 0x01, 0x02, 0x01, 0x00,

  // 0x7f - "домик".
  0x00, 0x3c, 0x26, 0x23, 0x26, 0x3c,

  // 0x80 - сетка из точек разреженная.
  0x44, 0x11, 0x44, 0x11, 0x44, 0x11,

  // 0x81 - сетка из точек густая.
  0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55,

  // 0x82 - сетка из черточек.
  0xbb, 0xee, 0xbb, 0xee, 0xbb, 0xee,

  // 0x83 - символы рамок псевдографики - вертикальная черта.
  0x00, 0x00, 0x00, 0xff, 0x00, 0x00,

  // 0x84 - псевдографика - вертикальная черта с отводом по центру влево.
  0x08, 0x08, 0x08, 0xff, 0x00, 0x00,

  // 0x85 - псевдографика - вертикальная черта с двойным отводом по центру влево.
  0x0a, 0x0a, 0x0a, 0xff, 0x00, 0x00,

  // 0x86 - псевдографика - двойная вертикальная черта с отводом по центру влево.
  0x08, 0xff, 0x00, 0xff, 0x00, 0x00,

  // 0x87 - псевдографика - верхний правый угол с двойной вертикальной чертой.
  0x08, 0xf8, 0x08, 0xf8, 0x00, 0x00,

  // 0x88 - псевдографика - верхний правый угол с двойной горизонтальной чертой.
  0x0a, 0x0a, 0x0a, 0xfe, 0x00, 0x00,

  // 0x89 - псевдографика - двойная вертикальная черта с двойным отводом по центру влево.
  0x0a, 0xfb, 0x00, 0xff, 0x00, 0x00,

  // 0x8a - псевдографика - двойная вертикальная черта.
  0x00, 0xff, 0x00, 0xff, 0x00, 0x00,

  // 0x8b - псевдографика - двойной верхний правый угол.
  0x0a, 0xfa, 0x02, 0xfe, 0x00, 0x00,

  // 0x8c - псевдографика - двойной нижний правый угол.
  0x0a, 0x0b, 0x08, 0x0f, 0x00, 0x00,

  // 0x8d - псевдографика - нижний правый угол с двойной вертикальной чертой.
  0x08, 0x0f, 0x08, 0x0f, 0x00, 0x00,

  // 0x8e - псевдографика - нижний правый угол с двойной горизонтальной чертой.
  0x0a, 0x0a, 0x0a, 0x0f, 0x00, 0x00,

  // 0x8f - псевдографика - верхний правый угол.
  0x08, 0x08, 0x08, 0xf8, 0x00, 0x00,

  // 0x90 - псевдографика - нижний левый угол.
  0x00, 0x00, 0x00, 0x0f, 0x08, 0x08,

  // 0x91 - псевдографика - горизонтальная черта с отводом по центру вверх.
  0x08, 0x08, 0x08, 0x0f, 0x08, 0x08,

  // 0x92 - псевдографика - горизонтальная черта с отводом по центру вниз.
  0x08, 0x08, 0x08, 0xf8, 0x08, 0x08,

  // 0x93 - псевдографика - вертикальная черта с отводом по центру вправо.
  0x00, 0x00, 0x00, 0xff, 0x08, 0x08,

  // 0x94 - псевдографика - горизонтальная черта по центру.
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08,

  // 0x95 - псевдографика - перекрестие.
  0x08, 0x08, 0x08, 0xff, 0x08, 0x08,

  // 0x96 - псевдографика - вертикальная черта с двойным отводом по центру вправо.
  0x00, 0x00, 0x00, 0xff, 0x0a, 0x0a,

  // 0x97 - псевдографика - двойная вертикальная черта с отводом по центру вправо.
  0x00, 0xff, 0x00, 0xff, 0x08, 0x08,

  // 0x98 - псевдографика - двойной нижний левый угол.
  0x00, 0x0f, 0x08, 0x0b, 0x0a, 0x0a,

  // 0x99 - псевдографика - двойной верхний левый угол.
  0x00, 0xfe, 0x02, 0xfa, 0x0a, 0x0a,

  // 0x9a - псевдографика - двойная горизонтальная черта с двойным отводом по центру вверх.
  0x0a, 0x0b, 0x08, 0x0b, 0x0a, 0x0a,

  // 0x9b - псевдографика - двойная горизонтальная черта с двойным отводом по центру вниз.
  0x0a, 0xfa, 0x02, 0xfa, 0x0a, 0x0a,

  // 0x9c - псевдографика - двойная вертикальная черта с двойным отводом по центру вправо.
  0x00, 0xff, 0x00, 0xfb, 0x0a, 0x0a,

  // 0x9d - псевдографика - двойная горизонтальная черта по центру.
  0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,

  // 0x9e - псевдографика - двойное перекрестие.
  0x0a, 0xfb, 0x00, 0xfb, 0x0a, 0x0a,

  // 0x9f - псевдографика - двойная горизонтальная черта с отводом по центру вверх.
  0x0a, 0x0a, 0x0a, 0x0b, 0x0a, 0x0a,

  // 0xa0 - псевдографика - горизонтальная черта с двойным отводом по центру вверх.
  0x08, 0x0f, 0x08, 0x0f, 0x08, 0x08,

  // 0xa1 - псевдографика - двойная горизонтальная черта с отводом по центру вниз.
  0x0a, 0x0a, 0x0a, 0xfa, 0x0a, 0x0a,

  // 0xa2 - псевдографика - горизонтальная черта с двойным отводом по центру вниз.
  0x08, 0xf8, 0x08, 0xf8, 0x08, 0x08,

  // 0xa3 - псевдографика - нижний левый угол, двойная вертикальная черта.
  0x00, 0x0f, 0x08, 0x0f, 0x08, 0x08,

  // 0xa4 - псевдографика - нижний левый угол, двойная горизонтальная черта.
  0x00, 0x00, 0x00, 0x0f, 0x0a, 0x0a,

  // 0xa5 - псевдографика - верхний левый угол, двойная горизонтальная черта.
  0x00, 0x00, 0x00, 0xfe, 0x0a, 0x0a,

  // 0xa6 - псевдографика - верхний левый угол, двойная вертикальная черта.
  0x00, 0xf8, 0x08, 0xf8, 0x08, 0x08,

  // 0xa7 - псевдографика - двойная вертикальная черта по центру с отводами вправо и влево.
  0x08, 0xff, 0x08, 0xff, 0x08, 0x08,

  // 0xa8 - 'Ё'.
  0x00, 0x7e, 0x4b, 0x4a, 0x4b, 0x42,

  // 0xa9 - псевдографика - двойная горизонтальная черта по центру с отводами вверх и вниз.
  0x0a, 0x0a, 0x0a, 0xff, 0x0a, 0x0a,

  // 0xaa - псевдографика - нижний правый угол.
  0x08, 0x08, 0x08, 0x0f, 0x00, 0x00,

  // 0xab - псевдографика - верхний левый угол.
  0x00, 0x00, 0x00, 0xf8, 0x08, 0x08,

  // 0xac - псевдографика - закрашенное знакоместо.
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

  // 0xad - псевдографика - закрашенная нижняя половина знакоместа.
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,

  // 0xae - псевдографика - закрашенная левая половина знакоместа.
  0xff, 0xff, 0xff, 0x00, 0x00, 0x00,

  // 0xaf - псевдографика - закрашенная правая половина знакоместа.
  0x00, 0x00, 0x00, 0xff, 0xff, 0xff,

  // 0xb0 - псевдографика - закрашенная верхняя половина знакоместа.
  0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,

  // 0xb1 - зеркальная 'Э'.
  0x00, 0x3e, 0x49, 0x49, 0x41, 0x22,

  // 0xb2 - зеркальная 'э'.
  0x00, 0x38, 0x54, 0x54, 0x44, 0x28,

  // 0xb3 - 'I' с двумя точками вверху.
  0x00, 0x01, 0x40, 0x7e, 0x40, 0x01,

  // 0xb4 - 'i' с двумя точками вверху.
  0x00, 0x00, 0x01, 0x7c, 0x41, 0x00,

  // 0xb5 - 'Y' с тильдой вверху ('~').
  0x00, 0x27, 0x48, 0x4b, 0x48, 0x3f,

  // 0xb6 - 'y' с тильдой вверху ('~').
  0x00, 0x9d, 0xa2, 0x62, 0x3d, 0x00,

  // 0xb7 - маленький кружок вверху.
  0x00, 0x06, 0x09, 0x09, 0x06, 0x00,

  // 0xb8 - 'ё'.
  0x00, 0x38, 0x55, 0x54, 0x55, 0x08,

  // 0xb9 - большой закрашенный круг по центру.
  0x00, 0x00, 0x18, 0x18, 0x00, 0x00,

  // 0xba - маленький закрашенный круг по центру.
  0x00, 0x00, 0x08, 0x00, 0x00, 0x00,

  // 0xbb - символ корня квадратного.
  0x00, 0x30, 0x40, 0x3e, 0x02, 0x02,

  
  0x7f, 0x06, 0x18, 0x7f, 0x13, 0x13, // 0xbc - '№'.
  0x2a, 0x3e, 0x14, 0x14, 0x3e, 0x2a, // 0xbd - "солнце".
  0x00, 0x3c, 0x3c, 0x3c, 0x3c, 0x00, // 0xbe - закрашенный квадрат по центру.
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xbf - пустое знакоместо.
  0x00, 0x7e, 0x11, 0x11, 0x11, 0x7e, // 0xc0 - 'А'.
  0x00, 0x7f, 0x49, 0x49, 0x49, 0x31, // 0xc1 - 'Б'.
  0x00, 0x7f, 0x49, 0x49, 0x49, 0x36, // 0xc2 - 'В'.
  0x00, 0x7f, 0x01, 0x01, 0x01, 0x01, // 0xc3 - 'Г'.
  0xc0, 0x7e, 0x41, 0x41, 0x7f, 0xc0, // 0xc4 - 'Д'.
  0x00, 0x7f, 0x49, 0x49, 0x49, 0x41, // 0xc5 - 'Е'.
  0x00, 0x77, 0x08, 0x7f, 0x08, 0x77, // 0xc6 - 'Ж'.
  0x22, 0x49, 0x49, 0x49, 0x36, 0x00, // 0xc7 - 'З'.
  0x00, 0x7f, 0x20, 0x10, 0x08, 0x7f, // 0xc8 - 'И'.
  0x00, 0x7e, 0x21, 0x11, 0x09, 0x7e, // 0xc9 - 'Й'.
  0x00, 0x7f, 0x08, 0x14, 0x22, 0x41, // 0xca - 'К'.
  0x00, 0x40, 0x7e, 0x01, 0x01, 0x7f, // 0xcb - 'Л'.
  0x00, 0x7f, 0x02, 0x04, 0x02, 0x7f, // 0xcc - 'М'.
  0x00, 0x7f, 0x08, 0x08, 0x08, 0x7f, // 0xcd - 'Н'.
  0x00, 0x3e, 0x41, 0x41, 0x41, 0x3e, // 0xce - 'О'.
  0x00, 0x7f, 0x01, 0x01, 0x01, 0x7f, // 0xcf - 'П'.
  0x00, 0x7f, 0x09, 0x09, 0x09, 0x06, // 0xd0 - 'Р'.
  0x00, 0x3e, 0x41, 0x41, 0x41, 0x22, // 0xd1 - 'С'.
  0x00, 0x01, 0x01, 0x7f, 0x01, 0x01, // 0xd2 - 'Т'.
  0x00, 0x27, 0x48, 0x48, 0x48, 0x3f, // 0xd3 - 'У'.
  0x00, 0x0e, 0x11, 0x7f, 0x11, 0x0e, // 0xd4 - 'Ф'.
  0x00, 0x63, 0x14, 0x08, 0x14, 0x63, // 0xd5 - 'Х'.
  0x00, 0x7f, 0x40, 0x40, 0x7f, 0xc0, // 0xd6 - 'Ц'.
  0x00, 0x07, 0x08, 0x08, 0x08, 0x7f, // 0xd7 - 'Ч'.
  0x00, 0x7f, 0x40, 0x7f, 0x40, 0x7f, // 0xd8 - 'Ш'.
  0x00, 0x7f, 0x40, 0x7f, 0x40, 0xff, // 0xd9 - 'Щ'.
  0x03, 0x01, 0x7f, 0x48, 0x48, 0x30, // 0xda - 'Ъ'.
  0x00, 0x7f, 0x48, 0x48, 0x30, 0x7f, // 0xdb - 'Ы'.
  0x00, 0x7f, 0x48, 0x48, 0x48, 0x30, // 0xdc - 'Ь'.
  0x00, 0x22, 0x41, 0x49, 0x49, 0x3e, // 0xdd - 'Э'.
  0x00, 0x7f, 0x08, 0x3e, 0x41, 0x3e, // 0xde - 'Ю'.
  0x00, 0x66, 0x19, 0x09, 0x09, 0x7f, // 0xdf - 'Я'.
  0x00, 0x20, 0x54, 0x54, 0x54, 0x78, // 0xe0 - 'а'.
  0x00, 0x3c, 0x4a, 0x4a, 0x4a, 0x31, // 0xe1 - 'б'.
  0x00, 0x7c, 0x54, 0x54, 0x54, 0x28, // 0xe2 - 'в'.
  0x00, 0x7c, 0x04, 0x04, 0x0c, 0x00, // 0xe3 - 'г'.
  0xc0, 0x78, 0x44, 0x44, 0x7c, 0xc0, // 0xe4 - 'д'.
  0x00, 0x38, 0x54, 0x54, 0x54, 0x08, // 0xe5 - 'е'.
  0x00, 0x6c, 0x10, 0x7c, 0x10, 0x6c, // 0xe6 - 'ж'.
  0x00, 0x28, 0x44, 0x54, 0x54, 0x28, // 0xe7 - 'з'.
  0x00, 0x7c, 0x20, 0x10, 0x08, 0x7c, // 0xe8 - 'и'.
  0x00, 0x7c, 0x20, 0x12, 0x0a, 0x7c, // 0xe9 - 'й'.
  0x00, 0x7c, 0x10, 0x28, 0x44, 0x00, // 0xea - 'к'.
  0x40, 0x38, 0x04, 0x04, 0x7c, 0x00, // 0xeb - 'л'.
  0x00, 0x7c, 0x08, 0x10, 0x08, 0x7c, // 0xec - 'м'.
  0x00, 0x7c, 0x10, 0x10, 0x10, 0x7c, // 0xed - 'н'.
  0x00, 0x38, 0x44, 0x44, 0x44, 0x38, // 0xee - 'о'.
  0x00, 0x7c, 0x04, 0x04, 0x04, 0x7c, // 0xef - 'п'.
  0x00, 0xfc, 0x44, 0x44, 0x44, 0x38, // 0xf0 - 'р'.
  0x00, 0x38, 0x44, 0x44, 0x44, 0x28, // 0xf1 - 'с'.
  0x00, 0x04, 0x04, 0x7c, 0x04, 0x04, // 0xf2 - 'т'.
  0x00, 0x9c, 0xa0, 0x60, 0x3c, 0x00, // 0xf3 - 'у'.
  0x00, 0x18, 0x24, 0x7c, 0x24, 0x18, // 0xf4 - 'ф'.
  0x00, 0x6c, 0x10, 0x10, 0x6c, 0x00, // 0xf5 - 'х'.
  0x00, 0x7c, 0x40, 0x40, 0x7c, 0xc0, // 0xf6 - 'ц'.
  0x00, 0x0c, 0x10, 0x10, 0x10, 0x7c, // 0xf7 - 'ч'.
  0x00, 0x7c, 0x40, 0x7c, 0x40, 0x7c, // 0xf8 - 'ш'.
  0x00, 0x7c, 0x40, 0x7c, 0x40, 0xfc, // 0xf9 - 'щ'.
  0x0c, 0x04, 0x7c, 0x50, 0x50, 0x20, // 0xfa - 'ъ'.
  0x00, 0x7c, 0x50, 0x50, 0x20, 0x7c, // 0xfb - 'ы'.
  0x00, 0x7c, 0x50, 0x50, 0x50, 0x20, // 0xfc - 'ь'.
  0x00, 0x28, 0x44, 0x54, 0x54, 0x38, // 0xfd - 'э'.
  0x00, 0x7c, 0x10, 0x38, 0x44, 0x38, // 0xfe - 'ю'.
  0x00, 0x48, 0x34, 0x14, 0x14, 0x7c  // 0xff - 'я'.
};

//
//-----init functions--------------------------------------------------------------
void LCD_PortsInit(void){
    // enable port clocking
    RCC_AHBPeriphClockCmd(RCC_AHBENR_GPIOAEN, ENABLE);
    RCC_AHBPeriphClockCmd(RCC_AHBENR_GPIOBEN, ENABLE);
    RCC_AHBPeriphClockCmd(RCC_AHBENR_GPIOCEN, ENABLE);
    RCC_AHBPeriphClockCmd(RCC_AHBENR_GPIODEN, ENABLE);
    RCC_AHBPeriphClockCmd(RCC_AHBENR_GPIOFEN, ENABLE);
    
    // Port F init (PF6  - R/W; PF7  - E)
    GPIO_InitTypeDef GPIOF_ini = {0};
    GPIOF_ini.GPIO_Pin = (RW_PIN | E_PIN);
    GPIOF_ini.GPIO_Mode = GPIO_Mode_OUT;                     // Otput push-pull mode
    GPIOF_ini.GPIO_Speed = GPIO_Speed_50MHz;
    GPIOF_ini.GPIO_OType = GPIO_OType_PP;
    GPIOF_ini.GPIO_PuPd = GPIO_PuPd_NOPULL;
    
    GPIO_Init(GPIOF, &GPIOF_ini);
    
    // Port A init (PA12 - RS)
    GPIO_InitTypeDef GPIOA_ini;
    GPIOA_ini.GPIO_Pin = RS_PIN;
    GPIOA_ini.GPIO_Mode = GPIO_Mode_OUT;                     // Otput push-pull mode
    GPIOA_ini.GPIO_Speed = GPIO_Speed_50MHz;
    GPIOA_ini.GPIO_OType = GPIO_OType_PP;
    GPIOA_ini.GPIO_PuPd = GPIO_PuPd_NOPULL;
    
    GPIO_Init(GPIOA, &GPIOA_ini);
    
    // Port C init (PC10 - DB0;  PC11 - DB1;  PC12 - DB2)
    GPIO_InitTypeDef GPIOC_ini = {0};
    GPIOC_ini.GPIO_Pin = (DB0_PIN | DB1_PIN | DB2_PIN);
    GPIOC_ini.GPIO_Mode = GPIO_Mode_OUT;                     // Otput push-pull mode
    GPIOC_ini.GPIO_Speed = GPIO_Speed_50MHz;
    GPIOC_ini.GPIO_OType = GPIO_OType_PP;
    GPIOC_ini.GPIO_PuPd = GPIO_PuPd_NOPULL;
    
    GPIO_Init(GPIOC, &GPIOC_ini);
    
    // Port D init (PD2  - DB3)
    GPIO_InitTypeDef GPIOD_ini = {0};
    GPIOD_ini.GPIO_Pin = DB3_PIN;
    GPIOD_ini.GPIO_Mode = GPIO_Mode_OUT;                     // Otput push-pull mode
    GPIOD_ini.GPIO_Speed = GPIO_Speed_50MHz;
    GPIOD_ini.GPIO_OType = GPIO_OType_PP;
    GPIOD_ini.GPIO_PuPd = GPIO_PuPd_NOPULL;
    
    GPIO_Init(GPIOD, &GPIOD_ini);
    
    // Port B init (PB3  - DB4;  PB4  - DB5; PB5 - DB6; PB6 - DB7; PB7  - RST)
    GPIO_InitTypeDef GPIOB_ini = {0};
    GPIOB_ini.GPIO_Pin = (DB4_PIN | DB5_PIN | DB6_PIN | DB7_PIN | RST_PIN);
    GPIOB_ini.GPIO_Mode = GPIO_Mode_OUT;                  // Otput push-pull mode
    GPIOB_ini.GPIO_Speed = GPIO_Speed_50MHz;
    GPIOB_ini.GPIO_OType = GPIO_OType_PP;
    GPIOB_ini.GPIO_PuPd = GPIO_PuPd_NOPULL;
    
    GPIO_Init(GPIOB, &GPIOB_ini);
    
    // Pins reset
	GPIO_WriteBit(GPIOA, RS_PIN, Bit_RESET);
	GPIO_WriteBit(GPIOF, RW_PIN, Bit_RESET);
	GPIO_WriteBit(GPIOF, E_PIN, Bit_RESET);
	GPIO_WriteBit(GPIOB, RST_PIN, Bit_RESET);
}

void LCD_Init(void){
    // wait > 40 ms after power on
    delay(40000);
    
    // reset system
    RST(0);
    delay(10000);
    // not reset system
    RST(1);
    
    // function set
    LCD_SendCommand(FUNCTION_SET_BASE); // 0011x0xx (RW = 0, RS = 0)
    // wait > 100 mks
    delay(300);
    
    // function set again
    LCD_SendCommand(FUNCTION_SET_BASE); // 0011x0xx
    // wait > 37 mks
    delay(100);
    
    // display status
    LCD_SendCommand(DISPLAY_ON); // display on
    // wait > 100 mks
    delay(200);
    
    LCD_SendCommand(CLEAR_DISPLAY); // clear display
    // wait > 10 ms
    delay(20000);
    
    LCD_SendCommand(ENTRY_MODE_RS); // cursor move right and no shift
    delay(10); 
    
    // enable grafical mode
    LCD_SendCommand(FUNCTION_SET_EXT);  // 0x30 + RE = 1. Go to extended instruction.
    delay(10);
	LCD_SendCommand(ENABLE_GRAFICAL_MODE);  // Enable graphical mode
	delay(10);
}

//
//-----send functions-----------------------------------------------------------
void LCD_SendCommand(uint8_t byte){
    RS(0);
    RW(0);
    
    E(1);
    DB7((byte >> 7) & 0x01);
    DB6((byte >> 6) & 0x01);
    DB5((byte >> 5) & 0x01);
    DB4((byte >> 4) & 0x01);
    DB3((byte >> 3) & 0x01);
    DB2((byte >> 2) & 0x01);
    DB1((byte >> 1) & 0x01);
    DB0(byte & 0x01);
    
    delay(8);
    E(0);
    
    // delay for command execution (or data send)
    delay(72);
}
void LCD_SendByteData(uint8_t byte){
    RS(1);
    RW(0);
    
    E(1);
    DB7((byte >> 7) & 0x01);
    DB6((byte >> 6) & 0x01);
    DB5((byte >> 5) & 0x01);
    DB4((byte >> 4) & 0x01);
    DB3((byte >> 3) & 0x01);
    DB2((byte >> 2) & 0x01);
    DB1((byte >> 1) & 0x01);
    DB0(byte & 0x01);
    
    delay(8);
    E(0);
    
    // delay for command execution (or data send)
    delay(72);
}

void LCD_SetAddr(uint8_t vertAddr, uint8_t horizAddr){
    // address auto increase after set y (0x3F (63) max) and x (0x0F (15) max) address
    
    // set y address [0, 63]
    LCD_SendCommand((SET_GDRAM_ADDR | (vertAddr & 0x3F)));
  
    // set x address [0, 15]
    LCD_SendCommand((SET_GDRAM_ADDR | (horizAddr & 0x0F)));
}
//
//-----functions with displayBuffer-------------------------------------------
uint8_t LCD_GetHorizontalByte(uint8_t *pBuff, uint8_t Row, uint8_t Col){ // how is it work?????
  uint8_t Byte = 0;
  
  // calculation start byte index
  uint16_t ByteIdx = (Row >> 3) * DISPLAY_WIDTH;         // Index of row start in displayBuffer
  ByteIdx += (Col << 3);
  
  // Bit mask, which selects a row of eight px in displayBuffer
  uint8_t BitMask = Row % 8;
  BitMask = (1 << BitMask);
  
  // Selects 8 bits
  for (uint8_t Bit = 0; Bit < 8; Bit++)
  {
    if (pBuff[ByteIdx + Bit] & BitMask)
      Byte |= (1 << (7 - Bit));
  }
  
  return Byte;
}

void LCD_BufferShiftPage(uint8_t *pBuff, uint8_t page, uint8_t direct, uint8_t isCyclic){
    // remember first or last element if it is a cyclic shift
    uint8_t temp;
    if(isCyclic == CYCLIC_SHIFT){
        temp = (direct == RIGHT_SHIFT ? pBuff[(page+1)*DISPLAY_WIDTH-1] : pBuff[page*DISPLAY_WIDTH]);
    }
    
    if(direct == RIGHT_SHIFT){
        // shift array right
        int index;
        for(index = (page+1)*DISPLAY_WIDTH-1; index > page*DISPLAY_WIDTH; index--){
            pBuff[index] = pBuff[index-1];
        }
        pBuff[page*DISPLAY_WIDTH] = (isCyclic == CYCLIC_SHIFT ? temp : 0x00);
    } else{
        // shift array left
        int index;
        for(index = page*DISPLAY_WIDTH; index < (page+1)*DISPLAY_WIDTH - 1; index++){
            pBuff[index] = pBuff[index+1];
        }
        pBuff[(page+1)*DISPLAY_WIDTH-1] = (isCyclic == CYCLIC_SHIFT ? temp : 0x00);
    }
}

void LCD_WriteSymbolToBuffer(uint8_t *pBuff, char sumbol){	
	// max symbols in one line = 21, max on display = 84;
    if(lcdStruct.byteIndex > (LCD_BUFFER_LENGTH - 6)) lcdStruct.byteIndex = 0;
    
    if((DISPLAY_WIDTH - lcdStruct.byteIndex%DISPLAY_WIDTH < 6)){
        lcdStruct.byteIndex += DISPLAY_WIDTH - lcdStruct.byteIndex%DISPLAY_WIDTH;
    }
	
	// write one symbol to displayBuffer
	int i;
	for(i = 0; i < 6; i++)
	{
		pBuff[lcdStruct.byteIndex + i] = (uint8_t) LIBRARY_SYMBOL[ (sumbol * 6) + i ];
	}
    lcdStruct.byteIndex += 6;
}

void LCD_WriteStringToBuffer(uint8_t *pBuff, const char* str){
	int i;
	for(i = 0; str[i] != 0; i++)
	{
		LCD_WriteSymbolToBuffer(pBuff, str[i]);
	}
}

void LCD_DrawPageFromBuffer(uint8_t *pBuff, uint8_t page){
    for (uint8_t Row = (page << 3); Row < ((page+1) << 3); Row++)
    {
        LCD_SetAddr(Row, 0);
        for (uint8_t Col = 0; Col < 16; Col++){
            LCD_SendByteData(LCD_GetHorizontalByte(pBuff, Row, Col));
        }
    }
}

void LCD_DisplayFullUpdate(uint8_t *pBuff){
    for (uint8_t Row = 0; Row < 32; Row++)
    {
        // Select a new line
        LCD_SetAddr(Row, 0);
        
        // Draw a line one pixel high in the upper of the display
        for (uint8_t Col = 0; Col < 16; Col++)
            LCD_SendByteData(LCD_GetHorizontalByte(pBuff, Row, Col));
        // Draw a line one pixel high in the lower of the display
        for (uint8_t Col = 0; Col < 16; Col++)
            LCD_SendByteData(LCD_GetHorizontalByte(pBuff, Row + 32, Col));
    }
}

//
//----draw functions-----------------------------------------------------
void LCD_ClearOrFillDisplay(uint8_t isClear){
    uint8_t data = (isClear == CLEAR ? 0x00 : 0xFF);
    uint8_t Row, Col;
    for (Row = 0; Row < 32; Row++)
    {
        // Stay on start of new row in display buffer
        LCD_SetAddr(Row, 0);
    
        // Draw a line one pixel high in the upper of the display
        for (Col = 0; Col < 16; Col++)
            LCD_SendByteData(data);
        
        // Draw a line one pixel high in the lower of the display
        for (Col = 0; Col < 16; Col++)
            LCD_SendByteData(data);
    }
}

void LCD_RunLine(const char *str, uint8_t charCount, uint8_t page, uint8_t direct, uint8_t isCyclic){
    uint8_t runLineBuffer[LCD_BUFFER_LENGTH] = {0x00};
    
    long runLineDelay = 40000, shiftCount = 0;
    int i, j;
    // start filling with string
    if(direct == RIGHT_SHIFT){
        // right shift
        for(i = charCount-1; i >= 0; i--){
            for(j = 6; j > 0; j--){
                LCD_BufferShiftPage(runLineBuffer, page, direct, isCyclic);
                shiftCount++;
                runLineBuffer[page*DISPLAY_WIDTH] = (uint8_t) LIBRARY_SYMBOL[ (str[i] * 6) + j ];
                LCD_DrawPageFromBuffer(runLineBuffer, page);
                delay(runLineDelay); 
            }
        }
    } else{
        // left shift
        for(i = 0; i < charCount; i++){
            for(j = 0; j < 6; j++){
                LCD_BufferShiftPage(runLineBuffer, page, direct, isCyclic);
                shiftCount++;
                runLineBuffer[(page+1)*DISPLAY_WIDTH-1] = (uint8_t) LIBRARY_SYMBOL[ (str[i] * 6) + j ];
                LCD_DrawPageFromBuffer(runLineBuffer, page);
                delay(runLineDelay); 
            }
        }
    }
    
    // running line
    while(shiftCount < DISPLAY_WIDTH+charCount*6){
        LCD_BufferShiftPage(runLineBuffer, page, direct, isCyclic);
        shiftCount += (isCyclic == CYCLIC_SHIFT ? 0 : 1);
        LCD_DrawPageFromBuffer(runLineBuffer, page);
        delay(runLineDelay); 
    }
}
